/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/alpinejs/dist/alpine.js":
/*!**********************************************!*\
  !*** ./node_modules/alpinejs/dist/alpine.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function (global, factory) {\n   true ? module.exports = factory() : undefined;\n}(this, function () {\n  \"use strict\";\n\n  function _defineProperty(obj, key, value) {\n    return key in obj ? Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : obj[key] = value, obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      enumerableOnly && (symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      })), keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = null != arguments[i] ? arguments[i] : {};\n      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n\n    return target;\n  }\n\n  function arrayUnique(array) {\n    for (var a = array.concat(), i = 0; i < a.length; ++i) for (var j = i + 1; j < a.length; ++j) a[i] === a[j] && a.splice(j--, 1);\n\n    return a;\n  }\n\n  function isTesting() {\n    return navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\");\n  }\n\n  function saferEval(expression, dataContext, additionalHelperVariables = {}) {\n    return new Function([\"$data\", ...Object.keys(additionalHelperVariables)], `var result; with($data) { result = ${expression} }; return result`)(dataContext, ...Object.values(additionalHelperVariables));\n  }\n\n  function saferEvalNoReturn(expression, dataContext, additionalHelperVariables = {}) {\n    return new Function([\"dataContext\", ...Object.keys(additionalHelperVariables)], `with(dataContext) { ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables));\n  }\n\n  function isXAttr(attr) {\n    const name = replaceAtAndColonWithStandardSyntax(attr.name);\n    return /x-(on|bind|data|text|html|model|if|for|show|cloak|transition|ref)/.test(name);\n  }\n\n  function getXAttrs(el, type) {\n    return Array.from(el.attributes).filter(isXAttr).map(attr => {\n      const name = replaceAtAndColonWithStandardSyntax(attr.name),\n            typeMatch = name.match(/x-(on|bind|data|text|html|model|if|for|show|cloak|transition|ref)/),\n            valueMatch = name.match(/:([a-zA-Z\\-:]+)/),\n            modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n      return {\n        type: typeMatch ? typeMatch[1] : null,\n        value: valueMatch ? valueMatch[1] : null,\n        modifiers: modifiers.map(i => i.replace(\".\", \"\")),\n        expression: attr.value\n      };\n    }).filter(i => !type || i.type === type);\n  }\n\n  function replaceAtAndColonWithStandardSyntax(name) {\n    return name.startsWith(\"@\") ? name.replace(\"@\", \"x-on:\") : name.startsWith(\":\") ? name.replace(\":\", \"x-bind:\") : name;\n  }\n\n  function transitionIn(el, show, forceSkip = !1) {\n    if (forceSkip) return show();\n    const attrs = getXAttrs(el, \"transition\"),\n          showAttr = getXAttrs(el, \"show\")[0];\n\n    if (showAttr && showAttr.modifiers.includes(\"transition\")) {\n      let modifiers = showAttr.modifiers;\n      if (modifiers.includes(\"out\") && !modifiers.includes(\"in\")) return show();\n      const settingBothSidesOfTransition = modifiers.includes(\"in\") && modifiers.includes(\"out\");\n      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index < modifiers.indexOf(\"out\")) : modifiers, function (el, modifiers, showCallback) {\n        const styleValues = {\n          duration: modifierValue(modifiers, \"duration\", 150),\n          origin: modifierValue(modifiers, \"origin\", \"center\"),\n          first: {\n            opacity: 0,\n            scale: modifierValue(modifiers, \"scale\", 95)\n          },\n          second: {\n            opacity: 1,\n            scale: 100\n          }\n        };\n        transitionHelper(el, modifiers, showCallback, () => {}, styleValues);\n      }(el, modifiers, show);\n    } else attrs.length > 0 ? function (el, directives, showCallback) {\n      const enter = (directives.find(i => \"enter\" === i.value) || {\n        expression: \"\"\n      }).expression.split(\" \").filter(i => \"\" !== i),\n            enterStart = (directives.find(i => \"enter-start\" === i.value) || {\n        expression: \"\"\n      }).expression.split(\" \").filter(i => \"\" !== i),\n            enterEnd = (directives.find(i => \"enter-end\" === i.value) || {\n        expression: \"\"\n      }).expression.split(\" \").filter(i => \"\" !== i);\n      transitionClasses(el, enter, enterStart, enterEnd, showCallback, () => {});\n    }(el, attrs, show) : show();\n  }\n\n  function transitionOut(el, hide, forceSkip = !1) {\n    if (forceSkip) return hide();\n    const attrs = getXAttrs(el, \"transition\"),\n          showAttr = getXAttrs(el, \"show\")[0];\n\n    if (showAttr && showAttr.modifiers.includes(\"transition\")) {\n      let modifiers = showAttr.modifiers;\n      if (modifiers.includes(\"in\") && !modifiers.includes(\"out\")) return hide();\n      const settingBothSidesOfTransition = modifiers.includes(\"in\") && modifiers.includes(\"out\");\n      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index > modifiers.indexOf(\"out\")) : modifiers, function (el, modifiers, settingBothSidesOfTransition, hideCallback) {\n        const styleValues = {\n          duration: settingBothSidesOfTransition ? modifierValue(modifiers, \"duration\", 150) : modifierValue(modifiers, \"duration\", 150) / 2,\n          origin: modifierValue(modifiers, \"origin\", \"center\"),\n          first: {\n            opacity: 1,\n            scale: 100\n          },\n          second: {\n            opacity: 0,\n            scale: modifierValue(modifiers, \"scale\", 95)\n          }\n        };\n        transitionHelper(el, modifiers, () => {}, hideCallback, styleValues);\n      }(el, modifiers, settingBothSidesOfTransition, hide);\n    } else attrs.length > 0 ? function (el, directives, hideCallback) {\n      const leave = (directives.find(i => \"leave\" === i.value) || {\n        expression: \"\"\n      }).expression.split(\" \").filter(i => \"\" !== i),\n            leaveStart = (directives.find(i => \"leave-start\" === i.value) || {\n        expression: \"\"\n      }).expression.split(\" \").filter(i => \"\" !== i),\n            leaveEnd = (directives.find(i => \"leave-end\" === i.value) || {\n        expression: \"\"\n      }).expression.split(\" \").filter(i => \"\" !== i);\n      transitionClasses(el, leave, leaveStart, leaveEnd, () => {}, hideCallback);\n    }(el, attrs, hide) : hide();\n  }\n\n  function modifierValue(modifiers, key, fallback) {\n    if (-1 === modifiers.indexOf(key)) return fallback;\n    const rawValue = modifiers[modifiers.indexOf(key) + 1];\n    if (!rawValue) return fallback;\n    if (\"scale\" === key && isNaN(rawValue)) return fallback;\n\n    if (\"duration\" === key) {\n      let match = rawValue.match(/([0-9]+)ms/);\n      if (match) return match[1];\n    }\n\n    return \"origin\" === key && [\"top\", \"right\", \"left\", \"center\", \"bottom\"].includes(modifiers[modifiers.indexOf(key) + 2]) ? [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(\" \") : rawValue;\n  }\n\n  function transitionHelper(el, modifiers, hook1, hook2, styleValues) {\n    const opacityCache = el.style.opacity,\n          transformCache = el.style.transform,\n          transformOriginCache = el.style.transformOrigin,\n          noModifiers = !modifiers.includes(\"opacity\") && !modifiers.includes(\"scale\"),\n          transitionOpacity = noModifiers || modifiers.includes(\"opacity\"),\n          transitionScale = noModifiers || modifiers.includes(\"scale\"),\n          stages = {\n      start() {\n        transitionOpacity && (el.style.opacity = styleValues.first.opacity), transitionScale && (el.style.transform = `scale(${styleValues.first.scale / 100})`);\n      },\n\n      during() {\n        transitionScale && (el.style.transformOrigin = styleValues.origin), el.style.transitionProperty = [transitionOpacity ? \"opacity\" : \"\", transitionScale ? \"transform\" : \"\"].join(\" \").trim(), el.style.transitionDuration = `${styleValues.duration / 1e3}s`, el.style.transitionTimingFunction = \"cubic-bezier(0.4, 0.0, 0.2, 1)\";\n      },\n\n      show() {\n        hook1();\n      },\n\n      end() {\n        transitionOpacity && (el.style.opacity = styleValues.second.opacity), transitionScale && (el.style.transform = `scale(${styleValues.second.scale / 100})`);\n      },\n\n      hide() {\n        hook2();\n      },\n\n      cleanup() {\n        transitionOpacity && (el.style.opacity = opacityCache), transitionScale && (el.style.transform = transformCache), transitionScale && (el.style.transformOrigin = transformOriginCache), el.style.transitionProperty = null, el.style.transitionDuration = null, el.style.transitionTimingFunction = null;\n      }\n\n    };\n    transition(el, stages);\n  }\n\n  function transitionClasses(el, classesDuring, classesStart, classesEnd, hook1, hook2) {\n    const originalClasses = el.__x_original_classes || [],\n          stages = {\n      start() {\n        el.classList.add(...classesStart);\n      },\n\n      during() {\n        el.classList.add(...classesDuring);\n      },\n\n      show() {\n        hook1();\n      },\n\n      end() {\n        el.classList.remove(...classesStart.filter(i => !originalClasses.includes(i))), el.classList.add(...classesEnd);\n      },\n\n      hide() {\n        hook2();\n      },\n\n      cleanup() {\n        el.classList.remove(...classesDuring.filter(i => !originalClasses.includes(i))), el.classList.remove(...classesEnd.filter(i => !originalClasses.includes(i)));\n      }\n\n    };\n    transition(el, stages);\n  }\n\n  function transition(el, stages) {\n    stages.start(), stages.during(), requestAnimationFrame(() => {\n      const duration = 1e3 * Number(getComputedStyle(el).transitionDuration.replace(\"s\", \"\"));\n      stages.show(), requestAnimationFrame(() => {\n        stages.end(), setTimeout(() => {\n          stages.hide(), el.isConnected && stages.cleanup();\n        }, duration);\n      });\n    });\n  }\n\n  function deepProxy(target, proxyHandler) {\n    if (null === target) return target;\n    if (\"object\" != typeof target) return target;\n    if (target instanceof Node) return target;\n    if (target.$isAlpineProxy) return target;\n\n    for (let property in target) target[property] = deepProxy(target[property], proxyHandler);\n\n    return new Proxy(target, proxyHandler);\n  }\n\n  function handleForDirective(component, el, expression, initialUpdate) {\n    const {\n      single: single,\n      bunch: bunch,\n      iterator1: iterator1,\n      iterator2: iterator2\n    } = function (expression) {\n      const forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/,\n            inMatch = expression.match(/([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/);\n      if (!inMatch) return;\n      const res = {};\n      res.bunch = inMatch[2].trim();\n      const single = inMatch[1].trim().replace(/^\\(|\\)$/g, \"\"),\n            iteratorMatch = single.match(forIteratorRE);\n      iteratorMatch ? (res.single = single.replace(forIteratorRE, \"\").trim(), res.iterator1 = iteratorMatch[1].trim(), iteratorMatch[2] && (res.iterator2 = iteratorMatch[2].trim())) : res.single = single;\n      return res;\n    }(expression);\n\n    var items = component.evaluateReturnExpression(el, bunch),\n        previousEl = el;\n    items.forEach((i, index, group) => {\n      const currentKey = function (component, el, single, iterator1, iterator2, i, index, group) {\n        const keyAttr = getXAttrs(el, \"bind\").filter(attr => \"key\" === attr.value)[0];\n        let keyAliases = {\n          [single]: i\n        };\n        iterator1 && (keyAliases[iterator1] = index);\n        iterator2 && (keyAliases[iterator2] = group);\n        return keyAttr ? component.evaluateReturnExpression(el, keyAttr.expression, () => keyAliases) : index;\n      }(component, el, single, iterator1, iterator2, i, index, group);\n\n      let currentEl = previousEl.nextElementSibling;\n\n      if (currentEl && void 0 !== currentEl.__x_for_key) {\n        if (currentEl.__x_for_key !== currentKey) for (var tmpCurrentEl = currentEl; tmpCurrentEl;) {\n          if (tmpCurrentEl.__x_for_key === currentKey) {\n            el.parentElement.insertBefore(tmpCurrentEl, currentEl), currentEl = tmpCurrentEl;\n            break;\n          }\n\n          tmpCurrentEl = !(!tmpCurrentEl.nextElementSibling || void 0 === tmpCurrentEl.nextElementSibling.__x_for_key) && tmpCurrentEl.nextElementSibling;\n        }\n        delete currentEl.__x_for_key, currentEl.__x_for_alias = single, currentEl.__x_for_value = i, component.updateElements(currentEl, () => ({\n          [currentEl.__x_for_alias]: currentEl.__x_for_value\n        }));\n      } else {\n        const clone = document.importNode(el.content, !0);\n        el.parentElement.insertBefore(clone, currentEl), currentEl = previousEl.nextElementSibling, transitionIn(currentEl, () => {}, initialUpdate), currentEl.__x_for_alias = single, currentEl.__x_for_value = i, component.initializeElements(currentEl, () => ({\n          [currentEl.__x_for_alias]: currentEl.__x_for_value\n        }));\n      }\n\n      currentEl.__x_for_key = currentKey, previousEl = currentEl;\n    });\n\n    for (var nextElementFromOldLoop = !(!previousEl.nextElementSibling || void 0 === previousEl.nextElementSibling.__x_for_key) && previousEl.nextElementSibling; nextElementFromOldLoop;) {\n      const nextElementFromOldLoopImmutable = nextElementFromOldLoop,\n            nextSibling = nextElementFromOldLoop.nextElementSibling;\n      transitionOut(nextElementFromOldLoop, () => {\n        nextElementFromOldLoopImmutable.remove();\n      }), nextElementFromOldLoop = !(!nextSibling || void 0 === nextSibling.__x_for_key) && nextSibling;\n    }\n  }\n\n  function handleAttributeBindingDirective(component, el, attrName, expression, extraVars) {\n    var value = component.evaluateReturnExpression(el, expression, extraVars);\n    if (\"value\" === attrName) {\n      if (void 0 === value && expression.match(/\\./).length && (value = \"\"), \"radio\" === el.type) el.checked = el.value == value;else if (\"checkbox\" === el.type) {\n        if (Array.isArray(value)) {\n          let valueFound = !1;\n          value.forEach(val => {\n            val == el.value && (valueFound = !0);\n          }), el.checked = valueFound;\n        } else el.checked = !!value;\n      } else \"SELECT\" === el.tagName ? function (el, value) {\n        const arrayWrappedValue = [].concat(value).map(value => value + \"\");\n        Array.from(el.options).forEach(option => {\n          option.selected = arrayWrappedValue.includes(option.value || option.text);\n        });\n      }(el, value) : el.value = value;\n    } else if (\"class\" === attrName) {\n      if (Array.isArray(value)) {\n        const originalClasses = el.__x_original_classes || [];\n        el.setAttribute(\"class\", arrayUnique(originalClasses.concat(value)).join(\" \"));\n      } else if (\"object\" == typeof value) Object.keys(value).forEach(classNames => {\n        value[classNames] ? classNames.split(\" \").forEach(className => el.classList.add(className)) : classNames.split(\" \").forEach(className => el.classList.remove(className));\n      });else {\n        const originalClasses = el.__x_original_classes || [],\n              newClasses = value.split(\" \");\n        el.setAttribute(\"class\", arrayUnique(originalClasses.concat(newClasses)).join(\" \"));\n      }\n    } else [\"disabled\", \"readonly\", \"required\", \"checked\", \"hidden\", \"selected\"].includes(attrName) ? value ? el.setAttribute(attrName, \"\") : el.removeAttribute(attrName) : el.setAttribute(attrName, value);\n  }\n\n  function registerListener(component, el, event, modifiers, expression, extraVars = {}) {\n    if (modifiers.includes(\"away\")) {\n      const handler = e => {\n        el.contains(e.target) || el.offsetWidth < 1 && el.offsetHeight < 1 || (runListenerHandler(component, expression, e, extraVars), modifiers.includes(\"once\") && document.removeEventListener(event, handler));\n      };\n\n      document.addEventListener(event, handler);\n    } else {\n      const listenerTarget = modifiers.includes(\"window\") ? window : modifiers.includes(\"document\") ? document : el,\n            handler = e => {\n        if (function (event) {\n          return [\"keydown\", \"keyup\"].includes(event);\n        }(event) && function (e, modifiers) {\n          let keyModifiers = modifiers.filter(i => ![\"window\", \"document\", \"prevent\", \"stop\"].includes(i));\n          if (0 === keyModifiers.length) return !1;\n          if (1 === keyModifiers.length && keyModifiers[0] === keyToModifier(e.key)) return !1;\n          const selectedSystemKeyModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\", \"cmd\", \"super\"].filter(modifier => keyModifiers.includes(modifier));\n\n          if (keyModifiers = keyModifiers.filter(i => !selectedSystemKeyModifiers.includes(i)), selectedSystemKeyModifiers.length > 0) {\n            if (selectedSystemKeyModifiers.filter(modifier => (\"cmd\" !== modifier && \"super\" !== modifier || (modifier = \"meta\"), e[`${modifier}Key`])).length === selectedSystemKeyModifiers.length && keyModifiers[0] === keyToModifier(e.key)) return !1;\n          }\n\n          return !0;\n        }(e, modifiers)) return;\n        modifiers.includes(\"prevent\") && e.preventDefault(), modifiers.includes(\"stop\") && e.stopPropagation(), !1 === runListenerHandler(component, expression, e, extraVars) ? e.preventDefault() : modifiers.includes(\"once\") && listenerTarget.removeEventListener(event, handler);\n      };\n\n      listenerTarget.addEventListener(event, handler);\n    }\n  }\n\n  function runListenerHandler(component, expression, e, extraVars) {\n    return component.evaluateCommandExpression(e.target, expression, () => _objectSpread2({}, extraVars(), {\n      $event: e\n    }));\n  }\n\n  function keyToModifier(key) {\n    switch (key) {\n      case \"/\":\n        return \"slash\";\n\n      case \" \":\n      case \"Spacebar\":\n        return \"space\";\n\n      default:\n        return key.replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[_\\s]/, \"-\").toLowerCase();\n    }\n  }\n\n  function generateModelAssignmentFunction(el, modifiers, expression) {\n    return \"radio\" === el.type && (el.hasAttribute(\"name\") || el.setAttribute(\"name\", expression)), (event, currentValue) => event instanceof CustomEvent && event.detail ? event.detail : \"checkbox\" === el.type ? Array.isArray(currentValue) ? event.target.checked ? currentValue.concat([event.target.value]) : currentValue.filter(i => i !== event.target.value) : event.target.checked : \"select\" === el.tagName.toLowerCase() && el.multiple ? modifiers.includes(\"number\") ? Array.from(event.target.selectedOptions).map(option => parseFloat(option.value || option.text)) : Array.from(event.target.selectedOptions).map(option => option.value || option.text) : modifiers.includes(\"number\") ? parseFloat(event.target.value) : modifiers.includes(\"trim\") ? event.target.value.trim() : event.target.value;\n  }\n\n  class Component {\n    constructor(el) {\n      this.$el = el;\n      const dataAttr = this.$el.getAttribute(\"x-data\"),\n            dataExpression = \"\" === dataAttr ? \"{}\" : dataAttr,\n            initExpression = this.$el.getAttribute(\"x-init\"),\n            createdExpression = this.$el.getAttribute(\"x-created\"),\n            mountedExpression = this.$el.getAttribute(\"x-mounted\"),\n            unobservedData = saferEval(dataExpression, {});\n      var initReturnedCallback;\n      this.$data = this.wrapDataInObservable(unobservedData), unobservedData.$el = this.$el, unobservedData.$refs = this.getRefsProxy(), this.nextTickStack = [], unobservedData.$nextTick = callback => {\n        this.nextTickStack.push(callback);\n      }, this.showDirectiveStack = [], this.showDirectiveLastElement, initExpression && (this.pauseReactivity = !0, initReturnedCallback = this.evaluateReturnExpression(this.$el, initExpression), this.pauseReactivity = !1), createdExpression && (console.warn('AlpineJS Warning: \"x-created\" is deprecated and will be removed in the next major version. Use \"x-init\" instead.'), this.pauseReactivity = !0, saferEvalNoReturn(this.$el.getAttribute(\"x-created\"), this.$data), this.pauseReactivity = !1), this.initializeElements(this.$el), this.listenForNewElementsToInitialize(), \"function\" == typeof initReturnedCallback && initReturnedCallback.call(this.$data), mountedExpression && (console.warn('AlpineJS Warning: \"x-mounted\" is deprecated and will be removed in the next major version. Use \"x-init\" (with a callback return) for the same behavior.'), saferEvalNoReturn(mountedExpression, this.$data));\n    }\n\n    wrapDataInObservable(data) {\n      var self = this;\n      const proxyHandler = {\n        set(obj, property, value) {\n          const setWasSuccessful = Reflect.set(obj, property, deepProxy(value, proxyHandler));\n          return self.pauseReactivity ? setWasSuccessful : ((func = () => {\n            for (self.updateElements(self.$el); self.nextTickStack.length > 0;) self.nextTickStack.shift()();\n          }, wait = 0, function () {\n            var context = this,\n                args = arguments,\n                later = function () {\n              timeout = null, func.apply(context, args);\n            };\n\n            clearTimeout(timeout), timeout = setTimeout(later, wait);\n          })(), setWasSuccessful);\n          var func, wait, timeout;\n        },\n\n        get: (target, key) => \"$isAlpineProxy\" === key || target[key]\n      };\n      return deepProxy(data, proxyHandler);\n    }\n\n    walkAndSkipNestedComponents(el, callback, initializeComponentCallback = () => {}) {\n      !function walk(el, callback) {\n        if (!1 === callback(el)) return;\n        let node = el.firstElementChild;\n\n        for (; node;) walk(node, callback), node = node.nextElementSibling;\n      }(el, el => el.hasAttribute(\"x-data\") && !el.isSameNode(this.$el) ? (el.__x || initializeComponentCallback(el), !1) : callback(el));\n    }\n\n    initializeElements(rootEl, extraVars = () => {}) {\n      for (this.walkAndSkipNestedComponents(rootEl, el => {\n        if (void 0 !== el.__x_for_key) return !1;\n        this.initializeElement(el, extraVars);\n      }, el => {\n        el.__x = new Component(el);\n      }), this.executeAndClearRemainingShowDirectiveStack(); this.nextTickStack.length > 0;) this.nextTickStack.shift()();\n    }\n\n    initializeElement(el, extraVars) {\n      el.hasAttribute(\"class\") && getXAttrs(el).length > 0 && (el.__x_original_classes = el.getAttribute(\"class\").split(\" \")), this.registerListeners(el, extraVars), this.resolveBoundAttributes(el, !0, extraVars);\n    }\n\n    updateElements(rootEl, extraVars = () => {}) {\n      for (this.walkAndSkipNestedComponents(rootEl, el => {\n        if (void 0 !== el.__x_for_key && !el.isSameNode(this.$el)) return !1;\n        this.updateElement(el, extraVars);\n      }, el => {\n        el.__x = new Component(el);\n      }), this.executeAndClearRemainingShowDirectiveStack(); this.nextTickStack.length > 0;) this.nextTickStack.shift()();\n    }\n\n    executeAndClearRemainingShowDirectiveStack() {\n      this.showDirectiveStack.reverse().map(thing => new Promise(resolve => {\n        thing(finish => {\n          resolve(finish);\n        });\n      })).reduce((nestedPromise, promise) => nestedPromise.then(() => promise.then(finish => finish())), Promise.resolve(() => {})), this.showDirectiveStack = [], this.showDirectiveLastElement = void 0;\n    }\n\n    updateElement(el, extraVars) {\n      this.resolveBoundAttributes(el, !1, extraVars);\n    }\n\n    registerListeners(el, extraVars) {\n      getXAttrs(el).forEach(({\n        type: type,\n        value: value,\n        modifiers: modifiers,\n        expression: expression\n      }) => {\n        switch (type) {\n          case \"on\":\n            registerListener(this, el, value, modifiers, expression, extraVars);\n            break;\n\n          case \"model\":\n            !function (component, el, modifiers, expression, extraVars) {\n              var event = \"select\" === el.tagName.toLowerCase() || [\"checkbox\", \"radio\"].includes(el.type) || modifiers.includes(\"lazy\") ? \"change\" : \"input\";\n              registerListener(component, el, event, modifiers, `${expression} = rightSideOfExpression($event, ${expression})`, () => _objectSpread2({}, extraVars(), {\n                rightSideOfExpression: generateModelAssignmentFunction(el, modifiers, expression)\n              }));\n            }(this, el, modifiers, expression, extraVars);\n        }\n      });\n    }\n\n    resolveBoundAttributes(el, initialUpdate = !1, extraVars) {\n      getXAttrs(el).forEach(({\n        type: type,\n        value: value,\n        modifiers: modifiers,\n        expression: expression\n      }) => {\n        switch (type) {\n          case \"model\":\n            handleAttributeBindingDirective(this, el, \"value\", expression, extraVars);\n            break;\n\n          case \"bind\":\n            if (\"template\" === el.tagName.toLowerCase() && \"key\" === value) return;\n            handleAttributeBindingDirective(this, el, value, expression, extraVars);\n            break;\n\n          case \"text\":\n            void 0 === (output = this.evaluateReturnExpression(el, expression, extraVars)) && expression.match(/\\./).length && (output = \"\"), el.innerText = output;\n            break;\n\n          case \"html\":\n            el.innerHTML = this.evaluateReturnExpression(el, expression, extraVars);\n            break;\n\n          case \"show\":\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            !function (component, el, value, modifiers, initialUpdate = !1) {\n              const handle = resolve => {\n                value ? (\"\" !== el.style.display && transitionIn(el, () => {\n                  1 === el.style.length ? el.removeAttribute(\"style\") : el.style.removeProperty(\"display\");\n                }, initialUpdate), resolve(() => {})) : \"none\" !== el.style.display ? transitionOut(el, () => {\n                  resolve(() => {\n                    el.style.display = \"none\";\n                  });\n                }, initialUpdate) : resolve(() => {});\n              };\n\n              modifiers.includes(\"immediate\") ? handle(finish => finish()) : (component.showDirectiveLastElement && !component.showDirectiveLastElement.contains(el) && component.executeAndClearRemainingShowDirectiveStack(), component.showDirectiveStack.push(handle), component.showDirectiveLastElement = el);\n            }(this, el, output, modifiers, initialUpdate);\n            break;\n\n          case \"if\":\n            output = this.evaluateReturnExpression(el, expression, extraVars);\n            !function (el, expressionResult, initialUpdate) {\n              \"template\" !== el.nodeName.toLowerCase() && console.warn(\"Alpine: [x-if] directive should only be added to <template> tags. See https://github.com/alpinejs/alpine#x-if\");\n              const elementHasAlreadyBeenAdded = el.nextElementSibling && !0 === el.nextElementSibling.__x_inserted_me;\n\n              if (expressionResult && !elementHasAlreadyBeenAdded) {\n                const clone = document.importNode(el.content, !0);\n                el.parentElement.insertBefore(clone, el.nextElementSibling), el.nextElementSibling.__x_inserted_me = !0, transitionIn(el.nextElementSibling, () => {}, initialUpdate);\n              } else !expressionResult && elementHasAlreadyBeenAdded && transitionOut(el.nextElementSibling, () => {\n                el.nextElementSibling.remove();\n              }, initialUpdate);\n            }(el, output, initialUpdate);\n            break;\n\n          case \"for\":\n            handleForDirective(this, el, expression, initialUpdate);\n            break;\n\n          case \"cloak\":\n            el.removeAttribute(\"x-cloak\");\n        }\n      });\n    }\n\n    evaluateReturnExpression(el, expression, extraVars = () => {}) {\n      return saferEval(expression, this.$data, _objectSpread2({}, extraVars(), {\n        $dispatch: this.getDispatchFunction(el)\n      }));\n    }\n\n    evaluateCommandExpression(el, expression, extraVars = () => {}) {\n      return saferEvalNoReturn(expression, this.$data, _objectSpread2({}, extraVars(), {\n        $dispatch: this.getDispatchFunction(el)\n      }));\n    }\n\n    getDispatchFunction(el) {\n      return (event, detail = {}) => {\n        el.dispatchEvent(new CustomEvent(event, {\n          detail: detail,\n          bubbles: !0\n        }));\n      };\n    }\n\n    listenForNewElementsToInitialize() {\n      const targetNode = this.$el;\n      new MutationObserver(mutations => {\n        for (let i = 0; i < mutations.length; i++) {\n          const closestParentComponent = mutations[i].target.closest(\"[x-data]\");\n          if (!closestParentComponent || !closestParentComponent.isSameNode(this.$el)) return;\n\n          if (\"attributes\" === mutations[i].type && \"x-data\" === mutations[i].attributeName) {\n            const rawData = saferEval(mutations[i].target.getAttribute(\"x-data\"), {});\n            Object.keys(rawData).forEach(key => {\n              this.$data[key] !== rawData[key] && (this.$data[key] = rawData[key]);\n            });\n          }\n\n          mutations[i].addedNodes.length > 0 && mutations[i].addedNodes.forEach(node => {\n            1 === node.nodeType && (node.matches(\"[x-data]\") ? node.__x = new Component(node) : this.initializeElements(node));\n          });\n        }\n      }).observe(targetNode, {\n        childList: !0,\n        attributes: !0,\n        subtree: !0\n      });\n    }\n\n    getRefsProxy() {\n      var self = this;\n      return new Proxy({}, {\n        get(object, property) {\n          return \"$isAlpineProxy\" === property || (self.walkAndSkipNestedComponents(self.$el, el => {\n            el.hasAttribute(\"x-ref\") && el.getAttribute(\"x-ref\") === property && (ref = el);\n          }), ref);\n          var ref;\n        }\n\n      });\n    }\n\n  }\n\n  const Alpine = {\n    start: async function () {\n      isTesting() || (await new Promise(resolve => {\n        \"loading\" == document.readyState ? document.addEventListener(\"DOMContentLoaded\", resolve) : resolve();\n      })), this.discoverComponents(el => {\n        this.initializeComponent(el);\n      }), document.addEventListener(\"turbolinks:load\", () => {\n        this.discoverUninitializedComponents(el => {\n          this.initializeComponent(el);\n        });\n      }), this.listenForNewUninitializedComponentsAtRunTime(el => {\n        this.initializeComponent(el);\n      });\n    },\n    discoverComponents: function (callback) {\n      document.querySelectorAll(\"[x-data]\").forEach(rootEl => {\n        callback(rootEl);\n      });\n    },\n    discoverUninitializedComponents: function (callback, el = null) {\n      const rootEls = (el || document).querySelectorAll(\"[x-data]\");\n      Array.from(rootEls).filter(el => void 0 === el.__x).forEach(rootEl => {\n        callback(rootEl);\n      });\n    },\n    listenForNewUninitializedComponentsAtRunTime: function (callback) {\n      const targetNode = document.querySelector(\"body\");\n      new MutationObserver(mutations => {\n        for (let i = 0; i < mutations.length; i++) mutations[i].addedNodes.length > 0 && mutations[i].addedNodes.forEach(node => {\n          1 === node.nodeType && (node.parentElement && node.parentElement.closest(\"[x-data]\") || this.discoverUninitializedComponents(el => {\n            this.initializeComponent(el);\n          }, node.parentElement));\n        });\n      }).observe(targetNode, {\n        childList: !0,\n        attributes: !0,\n        subtree: !0\n      });\n    },\n    initializeComponent: function (el) {\n      el.__x || (el.__x = new Component(el));\n    }\n  };\n  return isTesting() || (window.Alpine = Alpine, window.Alpine.start()), Alpine;\n});\n\n//# sourceURL=webpack:///./node_modules/alpinejs/dist/alpine.js?");

/***/ }),

/***/ "./src/css/app.css":
/*!*************************!*\
  !*** ./src/css/app.css ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/css/app.css?");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.css */ \"./src/css/app.css\");\n/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_app_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! alpinejs */ \"./node_modules/alpinejs/dist/alpine.js\");\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(alpinejs__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n//# sourceURL=webpack:///./src/js/app.js?");

/***/ })

/******/ });